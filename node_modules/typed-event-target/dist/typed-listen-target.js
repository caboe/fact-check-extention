import { check } from '@augment-vir/assert';
import { getOrSet } from '@augment-vir/common/dist/augments/object/get-or-set.js';
import { getObjectTypedValues } from '@augment-vir/common/dist/augments/object/object-values.js';
/**
 * Similar to `TypedEventTarget` except that it uses a `listen` method to add listeners and that
 * method returns a callback to remove the attached listener rather than having a
 * `removeEventListener` method.
 *
 * @category Main
 */
export class TypedListenTarget {
    listeners = {};
    /**
     * Get a count of all currently attached listeners. If a listener is removed, it will no longer
     * be counted.
     */
    getListenerCount() {
        const counts = getObjectTypedValues(this.listeners).map((listenersEntry) => listenersEntry.size || 0);
        return counts.reduce((accum, current) => accum + current, 0);
    }
    /**
     * Listen to events. Listening can be attached by a type string or by the event definition
     * itself.
     *
     * @returns A callback to remove the listener.
     */
    listen(eventTypeOrConstructor, listenerCallback, options = {}) {
        const listeners = this.listeners;
        const eventType = check.isString(eventTypeOrConstructor)
            ? eventTypeOrConstructor
            : eventTypeOrConstructor.type;
        function removeListener() {
            return listeners[eventType]?.delete(listenerCallback) || false;
        }
        function wrappedCallback(event, removeSelf) {
            if (options.once) {
                removeListener();
            }
            listenerCallback(event, removeSelf);
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        getOrSet(listeners, eventType, () => new Map()).set(listenerCallback, {
            listener: wrappedCallback,
            removeListener,
        });
        return removeListener;
    }
    /** Removes a listener. */
    removeListener(eventTypeOrConstructor, listenerCallback) {
        const eventType = check.isString(eventTypeOrConstructor)
            ? eventTypeOrConstructor
            : eventTypeOrConstructor.type;
        const eventTypeListeners = this.listeners[eventType];
        if (!eventTypeListeners) {
            return false;
        }
        const attachedListenerWrapper = eventTypeListeners.get(listenerCallback);
        if (!attachedListenerWrapper) {
            return false;
        }
        return attachedListenerWrapper.removeListener();
    }
    /**
     * Dispatch a typed event. Causes all attached listeners listening to this event to be fired.
     *
     * @returns The number of listeners that were fired.
     */
    dispatch(event) {
        const listenerSet = this.listeners[event.type];
        /**
         * This must be calculated before calling the listeners as the listeners might remove
         * themselves.
         */
        const size = listenerSet?.size || 0;
        listenerSet?.forEach((listenerWrapper) => {
            listenerWrapper.listener(event, listenerWrapper.removeListener);
        });
        return size;
    }
    /**
     * Remove all currently attached event listeners.
     *
     * @returns The number of listeners that were removed.
     */
    removeAllListeners() {
        const listenerSets = getObjectTypedValues(this.listeners);
        const totalRemoved = listenerSets.reduce((accum, listenerSet) => {
            const size = listenerSet.size || 0;
            listenerSet.clear();
            return accum + size;
        }, 0);
        this.listeners = {};
        return totalRemoved;
    }
    /** Remove all internal state to free up resources. */
    destroy() {
        this.removeAllListeners();
    }
}
/**
 * An alias for `TypedListenTarget`.
 *
 * @category Main
 */
export class ListenTarget extends TypedListenTarget {
}
