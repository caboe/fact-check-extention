// src/index.ts
import { resolve } from "path";
import { createRequire } from "module";
import {
  doc as doc3
} from "prettier";

// src/constants.ts
var scriptParser = "babel-ts";
var expressionParser = "__ts_expression";
var enclosedNodeTypeReg = /^(?:Identifier|.*Literal|(?:Object|Array|Parenthesized|Record|Tuple)Expression)$/;
var styleReg = /^style((?:\.[^\s\\/:*?"<>|({]+)+)?\s*\{?/;
var voidHTMLReg = /^(?:area|b(?:ase|r)|col|embed|hr|i(?:mg|nput)|keygen|link|meta|param|source|track|wbr)$/;
var shorthandIdOrClassReg = /^[a-zA-Z0-9_$][a-zA-Z0-9_$-]*(?:\s+[a-zA-Z0-9_$][a-zA-Z0-9_$-]*)*$/;
var preserveSpaceTagsReg = /^(?:textarea|pre)$/;

// src/utils/loc-to-pos.ts
function locToPos(loc, opts) {
  const { markoLinePositions } = opts;
  return markoLinePositions[loc.line - 1] + loc.column + (loc.line === 1 ? 0 : 1);
}

// src/utils/is-text-like.ts
function isTextLike(node, parent) {
  if (isText(node)) {
    return true;
  } else if (node.type === "MarkoComment") {
    const body = parent.type === "Program" ? parent.body : parent.body.body;
    const i = body.indexOf(node);
    let j = i;
    while (j > 0) {
      const check = body[--j];
      if (isText(check))
        return true;
      else if (check.type !== "MarkoComment")
        break;
    }
    j = i;
    while (j < body.length - 1) {
      const check = body[++j];
      if (isText(check))
        return true;
      else if (check.type !== "MarkoComment")
        break;
    }
  }
  return false;
}
function isText(node) {
  return node.type === "MarkoText" || node.type === "MarkoPlaceholder";
}

// src/utils/with-line-if-needed.ts
import { doc } from "prettier";
var { builders: b } = doc;
function withLineIfNeeded(node, opts, doc4) {
  const { originalText } = opts;
  let pos = locToPos(node.loc.start, opts);
  let count = 0;
  while (--pos >= 0) {
    let char = originalText[pos];
    if (char === "\n") {
      if (++count === 2) {
        while (--pos >= 0) {
          char = originalText[pos];
          if (char !== "\n" && char !== "	" && char !== "\r" && char !== " ") {
            return [b.hardline, doc4];
          }
        }
        return doc4;
      }
    } else if (char !== "	" && char !== "\r" && char !== " ") {
      break;
    }
  }
  return doc4;
}

// src/utils/with-block-if-needed.ts
import { doc as d } from "prettier";

// src/utils/outer-code-matches.ts
var enclosedPatterns = [];
enclosedPatterns.push(
  {
    // Ignored
    match: /[a-z0-9_$#@.]+/iy
  },
  {
    // Line comments
    match: /\/\/.*$/y
  },
  {
    // Multi line comments
    match: /\/\*.*?\*\//y
  },
  {
    // Parens
    match: /\(/y,
    patterns: enclosedPatterns,
    until: /\)/y
  },
  {
    // Braces
    match: /{/y,
    patterns: enclosedPatterns,
    until: /}/y
  },
  {
    // Brackets
    match: /\[/y,
    patterns: enclosedPatterns,
    until: /]/y
  },
  {
    // Single quote string
    match: /'(?:\\.|[^'\\]+)*'/y
  },
  {
    // Double quote string
    match: /"(?:\\.|[^"\\]+)*"/y
  },
  {
    // Template literal
    match: /`/y,
    patterns: [
      {
        // Content
        match: /\\.|\$(?!{)|[^`\\$]+/y
      },
      {
        // Expressions
        match: /\${/y,
        patterns: enclosedPatterns,
        until: /}/y
      }
    ],
    until: /`/y
  },
  {
    // RegExp
    match: /\/(?:\\.|\[(?:\\.|[^\]\\]+)\]|[^[/\\])+\/[a-z]*/iy
  }
);
var unenclosedPatterns = [
  {
    // Word operators
    match: /(?<=\b)\s*(?:as|in(?:stanceof)?|new|void|delete|keyof|typeof)\s+/y
  },
  {
    // Symbol operators
    match: /\s*(?:[\^~%!]|\+{1,2}|\*{1,2}|-(?:-(?!\s))?|&{1,2}|\|{1,2}|!={0,2}|===?|<{2,3}|>{2,3}|<=?|>=)\s*/y
  }
].concat(enclosedPatterns);
function outerCodeMatches(str, test, enclosed) {
  const stack = [
    {
      until: test,
      patterns: enclosed ? enclosedPatterns : unenclosedPatterns
    }
  ];
  let pos = 0;
  do {
    const { until, patterns } = stack[stack.length - 1];
    outer:
      while (pos < str.length) {
        for (const pattern of patterns) {
          pattern.match.lastIndex = pos;
          if (pattern.match.test(str)) {
            pos = pattern.match.lastIndex;
            if (pattern.until) {
              stack.push(pattern);
              break outer;
            } else {
              continue outer;
            }
          }
        }
        until.lastIndex = pos;
        if (until.test(str)) {
          pos = until.lastIndex;
          if (stack.length === 1)
            return true;
          stack.pop();
          break;
        }
        pos++;
      }
  } while (pos < str.length && stack.length);
  return false;
}

// src/utils/print-doc.ts
var DocCache = /* @__PURE__ */ new WeakMap();
function printDoc(doc4) {
  switch (typeof doc4) {
    case "string":
      return doc4;
    case "object":
      if (doc4 !== null) {
        let cached = DocCache.get(doc4);
        if (cached !== void 0)
          return cached;
        if (Array.isArray(doc4)) {
          cached = "";
          for (const item of doc4) {
            cached += printDoc(item);
          }
        } else {
          switch (doc4.type) {
            case "align":
              cached = `
${printDoc(doc4.contents)}
`;
              break;
            case "indent":
              cached = ` ${printDoc(doc4.contents)} `;
              break;
            case "break-parent":
            case "cursor":
            case "line-suffix-boundary":
            case "trim":
              cached = "";
              break;
            case "fill":
              cached = ` ${printDoc(doc4.parts)} `;
              break;
            case "group":
              cached = printDoc(doc4.contents) + printDoc(doc4.expandedStates);
              break;
            case "if-break":
              cached = printDoc(doc4.flatContents) + printDoc(doc4.breakContents);
              break;
            case "indent-if-break":
              cached = " ";
              break;
            case "label":
            case "line-suffix":
              cached = printDoc(doc4.contents);
              break;
            case "line":
            default:
              cached = "\n";
              break;
          }
        }
        DocCache.set(doc4, cached);
        return cached;
      }
  }
  return "";
}

// src/utils/with-block-if-needed.ts
var { builders: b2 } = d;
function withBlockIfNeeded(node, doc4) {
  if (!enclosedNodeTypeReg.test(node.type) && outerCodeMatches(printDoc(doc4).trim(), /[\n\r]/y)) {
    return b2.group([
      b2.indent([b2.ifBreak(["{", b2.line]), doc4]),
      b2.ifBreak([b2.line, "}"])
    ]);
  }
  return doc4;
}

// src/utils/with-parens-if-needed.ts
import { doc as d2 } from "prettier";
var { builders: b3 } = d2;
function withParensIfNeeded(node, doc4, enclosed) {
  var _a, _b;
  if (((_a = node.leadingComments) == null ? void 0 : _a.length) || ((_b = node.trailingComments) == null ? void 0 : _b.length) || !enclosedNodeTypeReg.test(node.type) && outerCodeMatches(printDoc(doc4).trim(), /\s|>/y, enclosed)) {
    return b3.group(["(", b3.indent([b3.softline, doc4]), b3.softline, ")"]);
  }
  return doc4;
}
function withParensIfBreak(node, doc4) {
  var _a, _b;
  if (((_a = node.leadingComments) == null ? void 0 : _a.length) || ((_b = node.trailingComments) == null ? void 0 : _b.length) || !enclosedNodeTypeReg.test(node.type) && outerCodeMatches(printDoc(doc4).trim(), /\n/y, true)) {
    return b3.group([
      b3.ifBreak("(", ""),
      b3.indent([b3.softline, doc4]),
      b3.softline,
      b3.ifBreak(")", "")
    ]);
  }
  return doc4;
}

// src/utils/as-literal-text-content.ts
import { doc as doc2 } from "prettier";
var { builders: b4 } = doc2;
var temp = [""];
function asLiteralTextContent(val) {
  let charPos = 0;
  let slotPos = 0;
  for (let i = 0, len = val.length; i < len; i++) {
    switch (val.charAt(i)) {
      case "\\":
        temp.push("\\\\");
        break;
      case "\n":
        temp.push(b4.literalline);
        break;
      default:
        continue;
    }
    temp[slotPos] = val.slice(charPos, i);
    slotPos = temp.push("") - 1;
    charPos = i + 1;
  }
  if (charPos) {
    const result = temp;
    result[slotPos] = val.slice(charPos);
    temp = [""];
    return result;
  } else {
    return val;
  }
}

// src/utils/get-original-code.ts
import babelGenerator from "@babel/generator";
var generate = babelGenerator.default || babelGenerator;
function getOriginalCodeForNode(opts, node) {
  var _a, _b;
  const hasLeadingComments = (_a = node.leadingComments) == null ? void 0 : _a.length;
  const hasTrailingComments = (_b = node.trailingComments) == null ? void 0 : _b.length;
  if (!hasLeadingComments && !hasTrailingComments) {
    switch (node.type) {
      case "StringLiteral":
        return JSON.stringify(node.value);
      case "BooleanLiteral":
      case "NumericLiteral":
        return "" + node.value;
      case "NullLiteral":
        return "null";
    }
  }
  const loc = node.loc;
  if (!loc) {
    return generate(node, {
      filename: opts.filepath,
      compact: false,
      comments: true,
      sourceMaps: false
    }).code;
  }
  let start = loc.start;
  if (hasLeadingComments) {
    const commentStart = node.leadingComments[0].loc.start;
    if (commentStart.line < start.line || commentStart.line === start.line && commentStart.column < start.column) {
      start = commentStart;
    }
  }
  let end = loc.end;
  if (hasTrailingComments) {
    const commentEnd = node.trailingComments[node.trailingComments.length - 1].loc.end;
    if (commentEnd.line > end.line || commentEnd.line === end.line && commentEnd.column > end.column) {
      end = commentEnd;
    }
  }
  return opts.originalText.slice(locToPos(start, opts), locToPos(end, opts));
}

// src/index.ts
var defaultFilePath = resolve("index.marko");
var rootRequire = createRequire(defaultFilePath);
var { builders: b5, utils } = doc3;
var identity = (val) => val;
var emptyArr = [];
var embeddedPlaceholderReg = /__EMBEDDED_PLACEHOLDER_(\d+)__/g;
var currentCompiler;
var currentConfig;
var languages = [
  {
    name: "marko",
    aceMode: "text",
    parsers: ["marko"],
    aliases: ["markojs"],
    tmScope: "text.marko",
    codemirrorMode: "htmlmixed",
    vscodeLanguageIds: ["marko"],
    linguistLanguageId: 932782397,
    codemirrorMimeType: "text/html",
    extensions: [".marko"]
  }
];
var options = {
  markoSyntax: {
    type: "choice",
    default: "auto",
    category: "Marko",
    description: "Change output syntax between HTML mode, concise mode and auto.",
    choices: [
      {
        value: "auto",
        description: "Determine output syntax by the input syntax used."
      },
      {
        value: "html",
        description: "Force the output to use the HTML syntax."
      },
      {
        value: "concise",
        description: "Force the output to use the concise syntax."
      }
    ]
  },
  markoAttrParen: {
    type: "boolean",
    default: (() => {
      try {
        const compilerRequire = createRequire(
          rootRequire.resolve("@marko/compiler")
        );
        const [major, minor] = compilerRequire("htmljs-parser/package.json").version.split(".").map((v) => parseInt(v, 10));
        return major < 2 || major === 2 && minor < 11;
      } catch {
        return false;
      }
    })(),
    category: "Marko",
    description: "If enabled all attributes with unenclosed whitespace will be wrapped in parens."
  }
};
var parsers = {
  marko: {
    astFormat: "marko-ast",
    async parse(text, opts) {
      ensureCompiler();
      const { filepath = defaultFilePath } = opts;
      const { compile, types: t } = currentCompiler;
      const { ast } = await compile(`${text}
`, filepath, currentConfig);
      opts.originalText = text;
      opts.markoLinePositions = [0];
      opts.markoPreservingSpace = false;
      for (let i = 0; i < text.length; i++) {
        if (text[i] === "\n") {
          opts.markoLinePositions.push(i);
        }
      }
      if (opts.markoSyntax === "auto") {
        opts.markoSyntax = "html";
        for (const childNode of ast.program.body) {
          if (t.isMarkoTag(childNode)) {
            if (t.isStringLiteral(childNode.name) && childNode.name.value === "style" && styleReg.exec(childNode.rawValue || "style")[0].endsWith("{")) {
              continue;
            }
            if (opts.originalText[locToPos(childNode.loc.start, opts)] !== "<") {
              opts.markoSyntax = "concise";
            }
            break;
          }
        }
      }
      t.traverseFast(ast, (node) => {
        if (node.type === "MarkoAttribute") {
          switch (node.name) {
            case "class":
            case "id":
              switch (node.value.type) {
                case "StringLiteral":
                case "ArrayExpression":
                case "TemplateLiteral":
                case "ObjectExpression":
                  node.value.loc = null;
                  break;
              }
              break;
          }
        }
      });
      return ast;
    },
    locStart(node) {
      var _a, _b;
      return ((_b = (_a = node.loc) == null ? void 0 : _a.start) == null ? void 0 : _b.index) || 0;
    },
    locEnd(node) {
      var _a, _b;
      return ((_b = (_a = node.loc) == null ? void 0 : _a.end) == null ? void 0 : _b.index) || 0;
    }
  }
};
var printers = {
  "marko-ast": {
    print(path, opts, print) {
      var _a, _b, _c, _d;
      const node = path.getNode();
      if (!node)
        return "";
      const { types: t } = currentCompiler;
      switch (node.type) {
        case "File":
          return path.call(print, "program");
        case "Program": {
          let text = [];
          const lastIndex = node.body.length - 1;
          const bodyDocs = [];
          path.each((child, i) => {
            const childNode = child.getNode();
            const isText2 = isTextLike(childNode, node);
            if (isText2) {
              text.push(print(child));
              if (i !== lastIndex)
                return;
            }
            if (text.length) {
              const textDoc = b5.group([
                "--",
                b5.line,
                b5.fill(text),
                b5.ifBreak([b5.softline, "--"])
              ]);
              if (isText2) {
                bodyDocs.push(textDoc);
              } else {
                text = [];
                bodyDocs.push(textDoc, b5.hardline, print(child));
              }
            } else {
              bodyDocs.push(print(child));
            }
          }, "body");
          return [b5.join(b5.hardline, bodyDocs), b5.hardline];
        }
        case "MarkoDocumentType":
          return `<!${node.value.replace(/\s+/g, " ").trim()}>`;
        case "MarkoDeclaration":
          return asLiteralTextContent(`<?${node.value}?>`);
        case "MarkoComment": {
          const start = (_a = node.loc) == null ? void 0 : _a.start;
          switch (start != null && opts.originalText[locToPos(start, opts) + 1]) {
            case "/":
              return [asLiteralTextContent(`//${node.value}`), b5.hardline];
            case "*":
              return asLiteralTextContent(`/*${node.value}*/`);
            default:
              return asLiteralTextContent(`<!--${node.value}-->`);
          }
        }
        case "MarkoCDATA":
          return asLiteralTextContent(`<![CDATA[${node.value}]]>`);
        case "MarkoTag": {
          const tagPath = path;
          const groupId = Symbol();
          const doc4 = [opts.markoSyntax === "html" ? "<" : ""];
          const { markoPreservingSpace } = opts;
          const literalTagName = t.isStringLiteral(node.name) ? node.name.value : "";
          const preserveSpace = markoPreservingSpace || (opts.markoPreservingSpace = preserveSpaceTagsReg.test(literalTagName));
          if (literalTagName) {
            doc4.push(literalTagName);
          } else {
            doc4.push(
              b5.group([
                "${",
                b5.indent([b5.softline, tagPath.call(print, "name")]),
                b5.softline,
                "}"
              ])
            );
          }
          if (node.typeArguments) {
            doc4.push(
              tagPath.call(print, "typeArguments")
            );
          }
          if (node.body.typeParameters) {
            if (!node.typeArguments) {
              doc4.push(" ");
            }
            doc4.push(
              tagPath.call(print, "body", "typeParameters")
            );
          }
          const shorthandIndex = doc4.push("") - 1;
          if (node.var) {
            doc4.push(
              "/",
              tagPath.call(
                print,
                "var"
              )
            );
          }
          if ((_b = node.arguments) == null ? void 0 : _b.length) {
            doc4.push(
              b5.group([
                "(",
                b5.indent([
                  b5.softline,
                  b5.join(
                    [",", b5.line],
                    tagPath.map((it) => print(it), "arguments")
                  ),
                  opts.trailingComma === "all" && !preventTrailingCommaTagArgs(literalTagName) ? b5.ifBreak(",") : ""
                ]),
                b5.softline,
                ")"
              ])
            );
          }
          if (node.body.params.length) {
            doc4.push(
              b5.group([
                "|",
                b5.indent([
                  b5.softline,
                  b5.join(
                    [",", b5.line],
                    tagPath.map((it) => print(it), "body", "params")
                  ),
                  opts.trailingComma === "all" ? b5.ifBreak(",") : ""
                ]),
                b5.softline,
                "|"
              ])
            );
          }
          if (node.attributes.length) {
            const attrsDoc = [];
            tagPath.each((attrPath) => {
              const attrNode = attrPath.getNode();
              if (t.isMarkoAttribute(attrNode) && (attrNode.name === "class" || attrNode.name === "id")) {
                if (opts.markoSyntax === "concise" && t.isStringLiteral(attrNode.value) && !attrNode.modifier && shorthandIdOrClassReg.test(attrNode.value.value)) {
                  const symbol = attrNode.name === "class" ? "." : "#";
                  doc4[shorthandIndex] += symbol + attrNode.value.value.split(/ +/).join(symbol);
                } else {
                  attrsDoc.push(print(attrPath));
                }
              } else if (attrNode.default) {
                doc4.push(print(attrPath));
              } else {
                attrsDoc.push(print(attrPath));
              }
            }, "attributes");
            if (attrsDoc.length) {
              if (attrsDoc.length === 1) {
                doc4.push(" ", attrsDoc[0]);
              } else {
                doc4.push(
                  b5.group([
                    opts.markoSyntax === "concise" ? b5.ifBreak(" [") : "",
                    b5.indent([b5.line, b5.join(b5.line, attrsDoc)]),
                    opts.markoSyntax === "concise" ? b5.ifBreak([b5.line, "]"]) : b5.ifBreak(b5.line)
                  ])
                );
              }
            }
          }
          if (voidHTMLReg.test(literalTagName)) {
            if (opts.markoSyntax === "html")
              doc4.push(">");
          } else if (node.body.body.length) {
            const lastIndex = node.body.body.length - 1;
            const bodyDocs = Array.isArray(node.attributeTags) ? tagPath.map(print, "attributeTags") : [];
            let textOnly = true;
            let textDocs = [];
            tagPath.each(
              (childPath, i) => {
                const childNode = childPath.getNode();
                const isText2 = isTextLike(childNode, node);
                if (isText2) {
                  textDocs.push(print(childPath));
                  if (i !== lastIndex)
                    return;
                } else {
                  textOnly = false;
                }
                if (textDocs.length) {
                  const isFirst = !bodyDocs.length;
                  bodyDocs.push(
                    b5.group([
                      opts.markoSyntax === "html" ? "" : isFirst ? b5.ifBreak("--", " --", { groupId }) : "--",
                      opts.markoSyntax === "html" ? "" : preserveSpace ? b5.hardline : b5.line,
                      preserveSpace ? textDocs : b5.fill(textDocs),
                      opts.markoSyntax === "html" ? "" : b5.ifBreak([b5.softline, "--"])
                    ])
                  );
                  if (!isText2) {
                    textDocs = [];
                    bodyDocs.push(print(childPath));
                  }
                } else {
                  bodyDocs.push(print(childPath));
                }
              },
              "body",
              "body"
            );
            const joinSep = (preserveSpace || !textOnly) && (opts.markoSyntax === "concise" || node.body.body.some((child) => child.type === "MarkoScriptlet")) ? b5.hardline : preserveSpace ? "" : b5.softline;
            const wrapSep = !preserveSpace && opts.markoSyntax === "html" && (node.var || node.body.params.length || ((_c = node.arguments) == null ? void 0 : _c.length) || node.attributes.length || node.body.body.some((child) => !isTextLike(child, node))) ? b5.hardline : joinSep;
            if (opts.markoSyntax === "html") {
              doc4.push(">");
            }
            if (joinSep || wrapSep) {
              doc4.push(b5.indent([wrapSep, b5.join(joinSep, bodyDocs)]));
              if (opts.markoSyntax === "html") {
                doc4.push(wrapSep);
              }
            } else {
              doc4.push(...bodyDocs);
            }
            if (opts.markoSyntax === "html") {
              doc4.push(`</${literalTagName}>`);
            }
          } else if (opts.markoSyntax === "html") {
            doc4.push("/>");
          }
          opts.markoPreservingSpace = markoPreservingSpace;
          return withLineIfNeeded(node, opts, b5.group(doc4, { id: groupId }));
        }
        case "MarkoAttribute": {
          const attrPath = path;
          const doc4 = [];
          const { value } = node;
          if (!node.default) {
            doc4.push(node.name);
            if (node.modifier) {
              doc4.push(`:${node.modifier}`);
            }
            if ((_d = node.arguments) == null ? void 0 : _d.length) {
              doc4.push(
                b5.group([
                  "(",
                  b5.indent([
                    b5.softline,
                    b5.join(
                      [",", b5.line],
                      attrPath.map((it) => print(it), "arguments")
                    ),
                    opts.trailingComma === "all" && !preventTrailingCommaAttrArgs(node.name) ? b5.ifBreak(",") : ""
                  ]),
                  b5.softline,
                  ")"
                ])
              );
            }
          }
          if (node.default || !t.isBooleanLiteral(value, { value: true })) {
            if (t.isFunctionExpression(value) && !(value.id || value.async || value.generator)) {
              doc4.push(attrPath.call(print, "value"));
            } else {
              doc4.push(
                node.bound ? ":=" : "=",
                b5.group(
                  withParensIfNeeded(
                    value,
                    attrPath.call(print, "value"),
                    opts.markoAttrParen
                  )
                )
              );
            }
          }
          return doc4;
        }
        case "MarkoSpreadAttribute": {
          return ["..."].concat(
            withParensIfNeeded(
              node.value,
              path.call(
                print,
                "value"
              ),
              opts.markoAttrParen
            )
          );
        }
        case "MarkoPlaceholder":
          return [
            node.escape ? "${" : "$!{",
            path.call(print, "value"),
            "}"
          ];
        case "MarkoScriptlet": {
          const bodyDocs = [];
          const prefix = node.static ? "static" : "$";
          path.each((childPath) => {
            const childNode = childPath.getNode();
            if (childNode && childNode.type !== "EmptyStatement") {
              bodyDocs.push(
                withLineIfNeeded(
                  childNode,
                  opts,
                  printSpecialDeclaration(childPath, prefix, opts, print) || [
                    prefix + " ",
                    withBlockIfNeeded(childNode, childPath.call(print))
                  ]
                )
              );
            }
          }, "body");
          return b5.join(b5.hardline, bodyDocs);
        }
        case "MarkoText": {
          const quote = opts.singleQuote ? "'" : '"';
          const escapedSpace = `\${${quote} ${quote}}`;
          const { value } = node;
          if (value === " " && (opts.markoSyntax === "concise" || path.getParentNode().type === "Program")) {
            return escapedSpace;
          }
          const breakValue = value.replace(/^ | $/g, escapedSpace);
          if (breakValue === value) {
            return asLiteralTextContent(value);
          }
          return b5.ifBreak(
            asLiteralTextContent(breakValue),
            asLiteralTextContent(value)
          );
        }
        default:
          throw new Error(`Unknown node type in Marko template: ${node.type}`);
      }
    },
    embed(path, opts) {
      ensureCompiler();
      const node = path.getNode();
      const type = node == null ? void 0 : node.type;
      const { types: t } = currentCompiler;
      switch (type) {
        case "File":
        case "Program":
          return null;
        case "MarkoClass":
          return (toDoc) => toDoc(
            `class ${getOriginalCodeForNode(
              opts,
              node.body
            )}`,
            { parser: expressionParser }
          );
        case "MarkoTag":
          if (node.name.type === "StringLiteral") {
            switch (node.name.value) {
              case "script":
                return async (toDoc, print) => {
                  var _a;
                  const placeholders = [];
                  const groupId = Symbol();
                  const parser = getScriptParser(node);
                  const doc4 = [
                    opts.markoSyntax === "html" ? "<" : "",
                    "script"
                  ];
                  let placeholderId = 0;
                  if (node.var) {
                    doc4.push(
                      "/",
                      path.call(print, "var")
                    );
                  }
                  if (node.attributes.length) {
                    const attrsDoc = [];
                    path.each((attrPath) => {
                      const attrNode = attrPath.getNode();
                      if (attrNode.default) {
                        doc4.push(print(attrPath));
                      } else {
                        attrsDoc.push(print(attrPath));
                      }
                    }, "attributes");
                    if (attrsDoc.length) {
                      if (attrsDoc.length === 1) {
                        doc4.push(" ", attrsDoc[0]);
                      } else {
                        doc4.push(
                          b5.group([
                            opts.markoSyntax === "concise" ? b5.ifBreak(" [") : "",
                            b5.indent([b5.line, b5.join(b5.line, attrsDoc)]),
                            opts.markoSyntax === "concise" ? b5.ifBreak([b5.line, "]"]) : b5.ifBreak(b5.line)
                          ])
                        );
                      }
                    }
                  }
                  if (node.body.body.length) {
                    const wrapSep = opts.markoSyntax === "html" && (node.var || node.body.params.length || ((_a = node.arguments) == null ? void 0 : _a.length) || node.attributes.length || node.body.body.some(
                      (child) => !isTextLike(child, node)
                    )) ? b5.hardline : opts.markoSyntax === "concise" || node.body.body.some(
                      (child) => child.type === "MarkoScriptlet"
                    ) ? b5.hardline : b5.softline;
                    if (opts.markoSyntax === "html") {
                      doc4.push(">");
                    }
                    let embeddedCode = "";
                    path.each(
                      (childPath) => {
                        const childNode = childPath.getNode();
                        if (childNode.type === "MarkoText") {
                          embeddedCode += childNode.value;
                        } else {
                          embeddedCode += `__EMBEDDED_PLACEHOLDER_${placeholderId++}__`;
                          placeholders.push(print(childPath));
                        }
                      },
                      "body",
                      "body"
                    );
                    const bodyDoc = b5.group([
                      opts.markoSyntax === "html" ? "" : b5.ifBreak("--", " --", { groupId }),
                      opts.markoSyntax === "html" ? "" : b5.line,
                      replaceEmbeddedPlaceholders(
                        parser === false ? asLiteralTextContent(embeddedCode.trim()) : await toDoc(embeddedCode, {
                          parser
                        }).catch(
                          () => asLiteralTextContent(embeddedCode.trim())
                        ),
                        placeholders
                      ),
                      opts.markoSyntax === "html" ? "" : b5.ifBreak([b5.softline, "--"])
                    ]);
                    doc4.push(b5.indent([wrapSep, bodyDoc]));
                    if (opts.markoSyntax === "html") {
                      doc4.push(wrapSep, `</script>`);
                    }
                  } else if (opts.markoSyntax === "html") {
                    doc4.push("/>");
                  }
                  return withLineIfNeeded(
                    node,
                    opts,
                    b5.group(doc4, { id: groupId })
                  );
                };
              case "style": {
                const rawValue = node.rawValue;
                const [startContent, lang] = styleReg.exec(
                  rawValue || "style"
                );
                const parser = lang ? getParserNameFromExt(lang) : "css";
                if (startContent.endsWith("{")) {
                  const codeSartOffset = startContent.length;
                  const codeEndOffset = node.rawValue.lastIndexOf("}");
                  const code = rawValue.slice(codeSartOffset, codeEndOffset).trim();
                  return async (toDoc) => {
                    try {
                      return withLineIfNeeded(
                        node,
                        opts,
                        b5.group([
                          "style",
                          !lang || lang === ".css" ? "" : lang,
                          " {",
                          b5.indent([
                            b5.line,
                            await toDoc(code, { parser }).catch(
                              () => asLiteralTextContent(code.trim())
                            )
                          ]),
                          b5.line,
                          "}"
                        ])
                      );
                    } catch {
                      return withLineIfNeeded(
                        node,
                        opts,
                        asLiteralTextContent(rawValue)
                      );
                    }
                  };
                } else {
                  return async (toDoc, print) => {
                    var _a;
                    const placeholders = [];
                    const groupId = Symbol();
                    const doc4 = [
                      opts.markoSyntax === "html" ? "<" : "",
                      "style",
                      !lang || lang === ".css" ? "" : lang
                    ];
                    let placeholderId = 0;
                    if (node.var) {
                      doc4.push(
                        "/",
                        path.call(print, "var")
                      );
                    }
                    if (!lang && node.attributes.length) {
                      const attrsDoc = [];
                      path.each((attrPath) => {
                        const attrNode = attrPath.getNode();
                        if (attrNode.default) {
                          doc4.push(print(attrPath));
                        } else {
                          attrsDoc.push(print(attrPath));
                        }
                      }, "attributes");
                      if (attrsDoc.length) {
                        if (attrsDoc.length === 1) {
                          doc4.push(" ", attrsDoc[0]);
                        } else {
                          doc4.push(
                            b5.group([
                              opts.markoSyntax === "concise" ? b5.ifBreak(" [") : "",
                              b5.indent([b5.line, b5.join(b5.line, attrsDoc)]),
                              opts.markoSyntax === "concise" ? b5.ifBreak([b5.line, "]"]) : b5.ifBreak(b5.line)
                            ])
                          );
                        }
                      }
                    }
                    if (node.body.body.length) {
                      const wrapSep = opts.markoSyntax === "html" && (node.var || node.body.params.length || ((_a = node.arguments) == null ? void 0 : _a.length) || node.attributes.length || node.body.body.some(
                        (child) => !isTextLike(child, node)
                      )) ? b5.hardline : opts.markoSyntax === "concise" || node.body.body.some(
                        (child) => child.type === "MarkoScriptlet"
                      ) ? b5.hardline : b5.softline;
                      if (opts.markoSyntax === "html") {
                        doc4.push(">");
                      }
                      let embeddedCode = "";
                      path.each(
                        (childPath) => {
                          const childNode = childPath.getNode();
                          if (childNode.type === "MarkoText") {
                            embeddedCode += childNode.value;
                          } else {
                            embeddedCode += `__EMBEDDED_PLACEHOLDER_${placeholderId++}__`;
                            placeholders.push(print(childPath));
                          }
                        },
                        "body",
                        "body"
                      );
                      const bodyDoc = b5.group([
                        opts.markoSyntax === "html" ? "" : b5.ifBreak("--", " --", { groupId }),
                        opts.markoSyntax === "html" ? "" : b5.line,
                        replaceEmbeddedPlaceholders(
                          await toDoc(embeddedCode, { parser }).catch(
                            () => asLiteralTextContent(embeddedCode.trim())
                          ),
                          placeholders
                        ),
                        opts.markoSyntax === "html" ? "" : b5.ifBreak([b5.softline, "--"])
                      ]);
                      doc4.push(b5.indent([wrapSep, bodyDoc]));
                      if (opts.markoSyntax === "html") {
                        doc4.push(wrapSep, `</style>`);
                      }
                    } else if (opts.markoSyntax === "html") {
                      doc4.push("/>");
                    }
                    return withLineIfNeeded(
                      node,
                      opts,
                      b5.group(doc4, { id: groupId })
                    );
                  };
                }
              }
            }
          }
      }
      if (type.startsWith("Marko"))
        return null;
      return async (toDoc, print) => {
        switch (node.type) {
          case "EmptyStatement":
            return void 0;
          case "ExportNamedDeclaration":
            if (node.declaration) {
              const printedDeclaration = path.call(
                (childPath) => printSpecialDeclaration(
                  childPath,
                  "export",
                  opts,
                  print
                ),
                "declaration"
              );
              if (printedDeclaration)
                return printedDeclaration;
            }
            break;
        }
        const code = getOriginalCodeForNode(
          opts,
          node
        );
        if (t.isStatement(node)) {
          return tryPrintEmbed(code, scriptParser);
        } else {
          const parent = path.getParentNode();
          const parentType = parent == null ? void 0 : parent.type;
          if (parentType === "MarkoTag" && path.key === "typeArguments") {
            return tryPrintEmbed(
              `_${code}`,
              scriptParser,
              (doc4) => {
                return doc4[1].contents;
              },
              code
            );
          } else if (parentType === "MarkoTagBody" && path.key === "typeParameters") {
            return tryPrintEmbed(
              `function _${code}() {}`,
              scriptParser,
              (doc4) => {
                return doc4[1].contents;
              },
              code
            );
          } else if (parentType === "MarkoTagBody" || parentType === "VariableDeclarator" && path.key === "id" || parentType === "MarkoTag" && path.key === "var") {
            return tryPrintEmbed(
              `var ${code}=_`,
              scriptParser,
              (doc4) => {
                const contents = doc4[0].contents[1].contents;
                for (let i = contents.length; i--; ) {
                  const item = contents[i];
                  if (typeof item === "string") {
                    const match = /\s*=\s*$/.exec(item);
                    if (match) {
                      contents[i] = item.slice(0, -match[0].length);
                      contents.length = i + 1;
                      break;
                    }
                  }
                }
                return contents;
              },
              code
            );
          } else if (parentType === "MarkoAttribute" && path.key === "value" && node.type === "FunctionExpression" && !(node.async || node.generator || node.id)) {
            return tryPrintEmbed(
              `({_${code.replace(/^\s*function\s*/, "")}})`,
              scriptParser,
              (doc4) => {
                return doc4[1].contents[1].contents[1].contents.slice(1);
              },
              code
            );
          }
          return tryPrintEmbed(code, expressionParser);
        }
        async function tryPrintEmbed(code2, parser, normalize = identity, fallback = code2) {
          try {
            return normalize(await toDoc(code2, { parser }));
          } catch {
            return [asLiteralTextContent(fallback)];
          }
        }
      };
    },
    getVisitorKeys(node) {
      ensureCompiler();
      return currentCompiler.types.VISITOR_KEYS[node.type] || emptyArr;
    }
  }
};
function setCompiler(compiler, config) {
  currentCompiler = compiler;
  setConfig(config);
}
function printSpecialDeclaration(path, prefix, opts, print) {
  const node = path.getNode();
  switch (node == null ? void 0 : node.type) {
    case "TSTypeAliasDeclaration":
      return [
        prefix + " type ",
        node.id.name,
        node.typeParameters ? [
          "<",
          b5.group([
            b5.indent([
              b5.softline,
              path.call(
                (paramsPath) => b5.join(
                  [",", b5.line],
                  paramsPath.map((param) => param.call(print))
                ),
                "typeParameters",
                "params"
              )
            ]),
            b5.softline,
            ">"
          ])
        ] : "",
        " = ",
        withParensIfBreak(
          node.typeAnnotation,
          path.call(print, "typeAnnotation")
        ),
        opts.semi ? ";" : ""
      ];
    case "VariableDeclaration": {
      return b5.join(
        b5.hardline,
        path.map((declPath) => {
          const decl = declPath.getNode();
          return [
            prefix + " " + (node.declare ? "declare " : "") + node.kind + " ",
            declPath.call(print, "id"),
            decl.init ? [
              " = ",
              withParensIfBreak(
                decl.init,
                declPath.call(print, "init")
              )
            ] : "",
            opts.semi ? ";" : ""
          ];
        }, "declarations")
      );
    }
  }
}
function replaceEmbeddedPlaceholders(doc4, placeholders) {
  if (!placeholders.length)
    return doc4;
  return utils.mapDoc(doc4, (cur) => {
    if (typeof cur === "string") {
      let match = embeddedPlaceholderReg.exec(cur);
      if (match) {
        const replacementDocs = [];
        let index = 0;
        do {
          const placeholderIndex = +match[1];
          if (index !== match.index) {
            replacementDocs.push(cur.slice(index, match.index));
          }
          replacementDocs.push(placeholders[placeholderIndex]);
          index = match.index + match[0].length;
        } while (match = embeddedPlaceholderReg.exec(cur));
        if (index !== cur.length) {
          replacementDocs.push(cur.slice(index));
        }
        if (replacementDocs.length === 1) {
          return replacementDocs[0];
        }
        return replacementDocs;
      }
    }
    return cur;
  });
}
function getParserNameFromExt(ext) {
  switch (ext) {
    case ".css":
      return "css";
    case ".less":
      return "less";
    case ".scss":
      return "scss";
    case ".js":
    case ".mjs":
    case ".cjs":
      return "babel";
    case ".ts":
    case ".mts":
    case ".cts":
      return "babel-ts";
  }
}
function preventTrailingCommaTagArgs(tagName) {
  switch (tagName) {
    case "if":
    case "else-if":
    case "while":
      return true;
    default:
      return false;
  }
}
function preventTrailingCommaAttrArgs(attrName) {
  switch (attrName) {
    case "if":
    case "while":
    case "no-update-if":
    case "no-update-body-if":
      return true;
    default:
      return false;
  }
}
function ensureCompiler() {
  if (!currentConfig) {
    let config;
    try {
      currentCompiler = rootRequire("@marko/compiler");
      config = rootRequire("@marko/compiler/config").default;
    } catch (cause) {
      throw new Error(
        "You must have @marko/compiler installed to use prettier-plugin-marko.",
        { cause }
      );
    }
    setConfig(config);
  }
}
function setConfig(config) {
  let { translator } = config;
  if (typeof translator === "string") {
    try {
      translator = rootRequire(translator);
    } catch {
    }
  }
  currentConfig = {
    ...config,
    translator,
    ast: true,
    code: false,
    optimize: false,
    output: "source",
    sourceMaps: false,
    writeVersionComment: false,
    babelConfig: {
      caller: { name: "@marko/prettier" },
      babelrc: false,
      configFile: false,
      parserOpts: {
        allowUndeclaredExports: true,
        allowAwaitOutsideFunction: true,
        allowReturnOutsideFunction: true,
        allowImportExportEverywhere: true,
        plugins: ["exportDefaultFrom", "importAssertions"]
      }
    }
  };
}
function getScriptParser(tag) {
  for (const attr of tag.attributes) {
    if (attr.type === "MarkoAttribute" && attr.name === "type") {
      switch (attr.value.type === "StringLiteral" ? attr.value.value : void 0) {
        case "module":
        case "text/javascript":
        case "application/javascript":
          return scriptParser;
        case "importmap":
        case "speculationrules":
          return "json";
        default:
          return false;
      }
    }
  }
  return scriptParser;
}
export {
  languages,
  options,
  parsers,
  printers,
  setCompiler
};
